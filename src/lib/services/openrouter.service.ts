import { z } from "zod";
import type { ExerciseDto, MuscleTestDto } from "../../types";

/**
 * Interface for OpenRouter API request
 */
interface OpenRouterRequest {
  model: string;
  messages: {
    role: "system" | "user" | "assistant";
    content: string;
  }[];
  max_tokens: number;
  temperature: number;
  stream?: boolean;
  headers?: Record<string, string>;
}

/**
 * Schema for validating the training plan JSON generated by OpenRouter
 */
export const TrainingPlanSchema = z.object({
  title: z.string(),
  description: z.string(),
  warnings: z.array(z.string()).optional(),
  exercises: z.array(
    z.object({
      id: z.number(),
      name: z.string(),
      description: z.string(),
      sets: z.number().int().positive(),
      reps: z.number().int().positive(),
      rest_time_seconds: z.number().int().nonnegative(),
      notes: z.string().optional(),
    })
  ),
});

export type TrainingPlan = z.infer<typeof TrainingPlanSchema>;

// Flag to use mock data instead of making real API calls (driven by env var OPENROUTER_USE_MOCK)
// To use mock data: set OPENROUTER_USE_MOCK=true in your .env or CLI; unset or false for real API calls
const USE_MOCK_DATA = true;

/**
 * Builds a prompt for the OpenRouter AI model to generate a personalized training plan
 * based on the selected muscle tests and their pain intensities
 */
export function buildTrainingPlanPrompt(
  bodyPartName: string,
  muscleTests: (MuscleTestDto & { pain_intensity: number })[],
  exercises: ExerciseDto[]
): string {
  // Format the muscle tests with pain intensities
  const formattedTests = muscleTests.map((test) => `- ${test.name}: Pain Intensity ${test.pain_intensity}/10 - ${test.description}`).join("\n");

  // Format the available exercises for each muscle test
  const formattedExercises = muscleTests
    .map((test) => {
      const testExercises = exercises.filter((ex) => ex.muscle_test_id === test.id);

      if (testExercises.length === 0) return "";

      const exerciseList = testExercises.map((ex) => `- Exercise ID ${ex.id}: ${ex.description}`).join("\n");

      return `Exercises for ${test.name}:\n${exerciseList}`;
    })
    .filter(Boolean)
    .join("\n\n");

  // Build the complete prompt
  return `
You are an AI physiotherapy assistant specialized in creating personalized training plans for patients with muscle pain.

PATIENT INFORMATION:
- Body Part: ${bodyPartName}
- Muscle Test Results:
${formattedTests}

AVAILABLE EXERCISES:
${formattedExercises}

TASK:
Create a personalized training plan for the patient based on their muscle test results and pain intensities.
Use only the exercises provided above. Prioritize exercises for muscle tests with higher pain intensities.

The training plan should be appropriate for the reported pain levels and focus on strengthening and rehabilitation.
For exercises selected from tests with high pain intensity (7-10), reduce the sets and reps.
For exercises selected from tests with medium pain intensity (4-6), use moderate sets and reps.
For exercises selected from tests with low pain intensity (1-3), use standard sets and reps.

Please return a JSON object with the following structure:
{
  "title": "Training Plan Title",
  "description": "Brief description of the overall plan and its goals",
  "warnings": ["Any specific warnings or precautions"],
  "exercises": [
    {
      "id": 123, // The Exercise ID from the available exercises
      "name": "Exercise Name",
      "description": "Brief instructions on how to perform the exercise",
      "sets": 3,
      "reps": 10,
      "rest_time_seconds": 60,
      "notes": "Any specific notes for this exercise"
    }
  ]
}

Ensure your response is ONLY the valid JSON object with no additional text.
`;
}

/**
 * Generate a mock training plan for development
 */
function generateMockTrainingPlan(
  bodyPartName: string,
  muscleTests: (MuscleTestDto & { pain_intensity: number })[],
  exercises: ExerciseDto[]
): TrainingPlan {
  // Sort tests by pain intensity (highest first)
  const sortedTests = [...muscleTests].sort((a, b) => b.pain_intensity - a.pain_intensity);

  // Select up to 5 exercises, prioritizing those from tests with higher pain
  const selectedExercises: ExerciseDto[] = [];
  for (const test of sortedTests) {
    const testExercises = exercises.filter((ex) => ex.muscle_test_id === test.id);
    if (testExercises.length > 0) {
      // Pick up to 2 exercises per test
      const max = Math.min(2, testExercises.length);
      for (let i = 0; i < max; i++) {
        selectedExercises.push(testExercises[i]);
        if (selectedExercises.length >= 5) break;
      }
    }
    if (selectedExercises.length >= 5) break;
  }

  // Create mock training plan
  return {
    title: `${bodyPartName} Recovery Plan`,
    description: `A personalized training plan to address pain in the ${bodyPartName} area, focusing on strength and mobility.`,
    warnings: ["Discontinue any exercise that causes sharp pain", "Consult with a healthcare professional if symptoms worsen"],
    exercises: selectedExercises.map((ex) => {
      // Get the test this exercise belongs to
      const test = muscleTests.find((t) => t.id === ex.muscle_test_id);
      const painLevel = test?.pain_intensity || 5;

      // Adjust sets and reps based on pain level
      let sets = 3;
      let reps = 12;

      if (painLevel >= 7) {
        sets = 2;
        reps = 8;
      } else if (painLevel >= 4) {
        sets = 3;
        reps = 10;
      }

      return {
        id: ex.id,
        name: `Exercise for ${test?.name || "Muscle"}`,
        description: ex.description,
        sets,
        reps,
        rest_time_seconds: 60,
        notes: painLevel >= 7 ? "Perform with caution due to high pain level" : undefined,
      };
    }),
  };
}

/**
 * Calls the OpenRouter AI API to generate a personalized training plan
 * based on the provided muscle tests and exercises
 *
 * @param bodyPartName - The name of the body part
 * @param muscleTests - The selected muscle tests with pain intensities
 * @param exercises - Available exercises for the selected muscle tests
 * @returns A promise resolving to a validated training plan or an error
 */
export async function generateTrainingPlan(
  bodyPartName: string,
  muscleTests: (MuscleTestDto & { pain_intensity: number })[],
  exercises: ExerciseDto[]
): Promise<{ trainingPlan: TrainingPlan | null; error: string | null }> {
  // When in mock mode, return mock data
  if (USE_MOCK_DATA) {
    console.log("Using mock training plan data");
    const mockPlan = generateMockTrainingPlan(bodyPartName, muscleTests, exercises);
    return { trainingPlan: mockPlan, error: null };
  }

  try {
    // Get OpenRouter API key from environment variables
    const apiKey = import.meta.env.OPENROUTER_API_KEY;
    if (!apiKey) {
      return { trainingPlan: null, error: "OpenRouter API key not configured" };
    }

    // Build the prompt for the AI model
    const prompt = buildTrainingPlanPrompt(bodyPartName, muscleTests, exercises);

    // Prepare the request to OpenRouter
    const request: OpenRouterRequest = {
      model: "openai/gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: "You are an AI physiotherapy assistant specialized in creating personalized training plans.",
        },
        {
          role: "user",
          content: prompt,
        },
      ],
      max_tokens: 2000,
      temperature: 0.2, // Lower temperature for more consistent responses
      headers: {
        "HTTP-Referer": "https://physia.app", // Domain for tracking in OpenRouter
        "X-Title": "Physia Exercise Plan Generator", // Application name
      },
    };

    // Set timeout for the request (60 seconds as mentioned in the requirements)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000);

    // Make the request to OpenRouter API
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify(request),
      signal: controller.signal,
    });

    // Clear the timeout
    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorData = await response.json();
      return {
        trainingPlan: null,
        error: `OpenRouter API error: ${errorData.error?.message || response.statusText}`,
      };
    }

    const data = await response.json();
    const generatedContent = data.choices[0]?.message?.content;

    if (!generatedContent) {
      return { trainingPlan: null, error: "No content generated by OpenRouter" };
    }

    // Parse the JSON response and validate against our schema
    try {
      // Extract JSON from the response (in case there's any extra text)
      const jsonMatch = generatedContent.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        return { trainingPlan: null, error: "Generated content does not contain valid JSON" };
      }

      const parsedJson = JSON.parse(jsonMatch[0]);
      const validationResult = TrainingPlanSchema.safeParse(parsedJson);

      if (!validationResult.success) {
        return {
          trainingPlan: null,
          error: `Training plan validation failed: ${validationResult.error.message}`,
        };
      }

      return { trainingPlan: validationResult.data, error: null };
    } catch (error) {
      return {
        trainingPlan: null,
        error: `Failed to parse training plan: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  } catch (error) {
    // Handle fetch errors (including timeout)
    if (error instanceof DOMException && error.name === "AbortError") {
      return { trainingPlan: null, error: "OpenRouter API request timed out after 60 seconds" };
    }

    return {
      trainingPlan: null,
      error: `Error generating training plan: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}
